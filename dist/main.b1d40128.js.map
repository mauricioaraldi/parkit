{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/styles/index.css?6349","webpack:///./src/styles/index.css","webpack:///./src/scripts/objects/Scene.js","webpack:///./src/scripts/constants.js","webpack:///./src/scripts/interface.js","webpack:///./src/scripts/utils.js","webpack:///./src/scripts/objects/Sensor.js","webpack:///./src/scripts/objects/GameObject.js","webpack:///./src/scripts/objects/Car.js","webpack:///./src/scripts/objects/Level.js","webpack:///./src/scripts/levelManager.js","webpack:///./src/scripts/stage.js","webpack:///./src/scripts/index.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","api","content","default","options","exported","locals","___CSS_LOADER_API_IMPORT___","GameObject","constructor","canvas","this","context","getContext","clear","clearRect","width","height","draw","objects","fill","Array","isArray","forEach","points","polygon","save","translate","pos","x","y","beginPath","moveTo","lineTo","closePath","fillStyle","color","strokeStyle","lineWidth","stroke","restore","checkCollisions","checkAllCollisions","collisions","objectA","objectB","SAT","testPolygonPolygon","BRAIN_TICKS_PER_SECOND","CANVAS_HEIGHT","CANVAS_WIDTH","CAR_HEIGHT","CAR_WIDTH","COLORS","asphalt","generic","goalArea","player","sensor","FRAMES_PER_SECOND","LS_CODE_KEY","MAX_ANGLE","MAX_ANGLE_CHANGE_PER_TICK","MAX_SPEED_CHANGE_PER_TICK","PIXELS_PER_METER","SENSOR_BREAKPOINTS_QT","SENSOR_METERS_RANGE","SENSORS_QT","SENSOR_RANGE","SPEED_RATIO","checkSensorsHighlighted","sections","document","querySelectorAll","activeSensors","sensorsQtPerSection","Constants","highlightAllCheckbox","querySelector","section","sectionActiveSensors","checked","setHighlightSensor","active","classList","add","setAttribute","remove","removeAttribute","createSensorInputs","sensorsQt","sectionContainers","sensorContainer","createElement","sensorTitle","sensorInput","sectionContainer","Math","floor","textContent","append","addEventListener","ev","stopPropagation","isActive","dataset","loadCode","code","localStorage","getItem","saveCode","setItem","toggleHighlightSection","target","parentElement","shouldHighlight","toggleHighlightSensors","updateSensorsDisplay","sensors","keys","reading","degreesToRadians","degrees","PI","Sensor","angle","range","breakpointQt","area","getSensorArea","originX","originY","interval","offset","Vector","cos","Utils","sin","updateReading","some","point","index","pointInPolygon","Polygon","testInsideAnotherObject","outerObject","innerStartX","innerEndX","innerStartY","innerEndY","outerStartX","outerEndX","outerStartY","outerEndY","Car","brainState","speed","parkingBreak","withSensors","sensorRange","sensorBreakpointQt","super","buildSensors","map","carPoint","angles","pointsPerAngle","updateSensors","proccessCarBrainAngle","angleState","angleChange","angleDiff","min","max","proccessCarBrainSpeed","speedState","speedChange","speedDiff","update","brainAngleChange","realSpeed","abs","angleRad","angleDiffRad","centerX","centerY","rotatedX","rotatedY","setPoints","Level","ground","limits","goalReachedAction","checkGoal","getLevel","id","colors","carWidth","carHeight","canvasWidth","canvasHeight","memory","Noty","text","type","show","gtag","drawSensors","sensorIds","car","ctx","CURRENT_LEVEL","codeMirror","animationTicker","brainTicker","animationTick","scene","level","highlightSensors","runSimulation","ids","parseInt","Stage","brainTick","sceneObjects","brainCode","getValue","carInstructions","newBrainState","Interface","eval","play","reset","currentLevel","LevelManager","Scene","setInterval","clearInterval","overrideDefaults","layout","theme","timeout","onload","CodeMirror","fromTextArea","lineNumbers","codeMirrorElement","codeMirrorTop","getClientRects","top","codeMirrorHeight","innerHeight","style","setValue","getDoc","element","input"],"mappings":"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","file":"main.b1d40128.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([16,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","var api = require(\"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../node_modules/css-loader/dist/cjs.js!./index.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(module.id, content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \"body {\\n  font-family: 'Open Sans';\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nbutton {\\n  font-size: 16px;\\n}\\n\\ncanvas {\\n  display: block;\\n  margin: 0 auto;\\n}\\n\\nh1, h3 {\\n  margin: 8px 0;\\n  padding: 0;\\n  text-align: center;\\n}\\n\\n#sensors {\\n  text-align: center;\\n}\\n\\n#sensors > h3 {\\n  display: inline-block;\\n}\\n\\n#sensors > label,\\n.sensor-section > label {\\n  border: 1px solid #000000;\\n  margin-left: 16px;\\n}\\n\\n#sensors > div {\\n  display: flex;\\n  justify-content: space-around;\\n}\\n\\n.sensor-section > h4 {\\n  display: inline-block;\\n  margin: 8px 0;\\n}\\n\\n.sensor-section > div {\\n  display: flex;\\n  grid-gap: 8px;\\n}\\n\\n.sensor {\\n  cursor: pointer;\\n  border: 1px solid #000000;\\n}\\n\\n.sensor.active,\\n.sensor.active input {\\n  background-color: #FED8B1;\\n}\\n\\n.sensor > span {\\n  margin: 0 8px;\\n}\\n\\n.sensor > input {\\n  cursor: pointer;\\n  text-align: right;\\n}\\n\\ninput {\\n  font-size: 16px;\\n\\twidth: 30px;\\n}\\n\\n#controls {\\n  margin: 8px 0;\\n  text-align: center;\\n}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","import SAT from 'sat';\n\n/**\n * @class\n *\n * @param {HTMLCanvasElement} canvas The canvas where to draw\n * @param {HTMLCanvasElement} context The context of the canvas\n */\nexport default class GameObject {\n  /**\n   * @constructor\n   *\n   * @param {HTMLCanvasElement} canvas The canvas where to draw\n   */\n  constructor(canvas) {\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d');\n  }\n\n  /**\n   * Clears the scene\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @return {[type]} [description]\n   */\n  clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  /**\n   * Draws the objects of the scene\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @param {GameObject[]} objects The objects to be drawn\n   * @param {Boolean} [fill = true] If the object should be filled with color\n   * @return {Boolean} If the objects were drawn\n   */\n  draw(objects, fill = true) {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n\n    objects.forEach((object) => {\n      const { points } = object.polygon;\n      let i = points.length - 1;\n\n      this.context.save();\n      this.context.translate(object.polygon.pos.x, object.polygon.pos.y);\n      this.context.beginPath();\n      this.context.moveTo(points[0].x, points[0].y);\n\n      while (i) {\n        this.context.lineTo(points[i].x, points[i].y);\n        i -= 1;\n      }\n\n      this.context.closePath();\n\n      if (fill) {\n        this.context.fillStyle = object.color;\n        this.context.fill();\n      } else {\n        this.context.strokeStyle = object.color;\n        this.context.lineWidth = 5;\n        this.context.stroke();\n      }\n\n      this.context.restore();\n    });\n\n    return true;\n  }\n\n  /**\n   * Checks for collisions between objects\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @param {GameObject[]} objects The objects to be checked\n   * @param {Boolean} checkAllCollisions If not only the first, but all, collisions\n   * should be returned\n   * @return {Array | Array<Array>} One or all detected collisions\n   */\n  checkCollisions(objects, checkAllCollisions) {\n    const collisions = [];\n\n    for (let i = objects.length - 1; i >= 0; i -= 1) {\n      const objectA = objects[i];\n\n      for (let j = i - 1; j >= 0; j -= 1) {\n        const objectB = objects[j];\n        const collided = SAT.testPolygonPolygon(objectA.polygon, objectB.polygon);\n\n        if (collided) {\n          collisions.push([objectA, objectB]);\n\n          if (!checkAllCollisions) {\n            return collisions[0];\n          }\n        }\n      }\n    }\n\n    return collisions;\n  }\n}\n","/* eslint object-property-newline: 0 */\n\nconst BRAIN_TICKS_PER_SECOND = 10;\nconst CANVAS_HEIGHT = 300;\nconst CANVAS_WIDTH = 1280;\nconst CAR_HEIGHT = 100;\nconst CAR_WIDTH = 200;\nconst COLORS = {\n  asphalt: '#282B2A',\n  generic: ['#F7DBD7', '#CBBFB0', '#FAEACB', '#BDC2C2', '#739194', '#88BCE8', '#9CC0E7', '#FCFCFC'],\n  goalArea: '#FFD700',\n  player: '#DB2929',\n  sensor: '#EEEEEE',\n};\nconst FRAMES_PER_SECOND = 24;\nconst LS_CODE_KEY = 'parkit_usercode';\nconst MAX_ANGLE = 35;\nconst MAX_ANGLE_CHANGE_PER_TICK = 0.6;\nconst MAX_SPEED_CHANGE_PER_TICK = 0.6;\nconst PIXELS_PER_METER = 10;\nconst SENSOR_METERS_RANGE = 7;\nconst SENSORS_QT = 20;\nconst SENSOR_RANGE = SENSOR_METERS_RANGE * PIXELS_PER_METER;\nconst SENSOR_BREAKPOINTS_QT = SENSOR_RANGE;\nconst SPEED_RATIO = 60;\n\nexport default {\n  BRAIN_TICKS_PER_SECOND, CANVAS_HEIGHT, CANVAS_WIDTH, CAR_HEIGHT, CAR_WIDTH, COLORS,\n  FRAMES_PER_SECOND, LS_CODE_KEY, MAX_ANGLE, MAX_ANGLE_CHANGE_PER_TICK, MAX_SPEED_CHANGE_PER_TICK,\n  PIXELS_PER_METER, SENSOR_BREAKPOINTS_QT, SENSOR_METERS_RANGE, SENSORS_QT, SENSOR_RANGE,\n  SPEED_RATIO,\n};\n","import Constants from './constants';\n\n/**\n * Updates the interface display of sensors\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {Sensor[]} The sensors of the car\n */\nfunction updateSensorsDisplay(sensors) {\n  Object.keys(sensors).forEach((key) => {\n    const sensorEl = document.querySelector(`#sensor${key}`);\n    sensorEl.value = sensors[key].reading;\n  });\n}\n\n/**\n * Checks if all sensors are highlighted and if the checkbox should\n * be checked\n *\n * @author mauricio.araldi\n * @since 0.2.0\n */\nfunction checkSensorsHighlighted() {\n  const sections = document.querySelectorAll('.sensor-section');\n  const activeSensors = document.querySelectorAll('.sensor.active');\n  const sensorsQtPerSection = Constants.SENSORS_QT / sections.length;\n  const highlightAllCheckbox = document.querySelector('#highlight-all-sensors');\n\n  sections.forEach((section) => {\n    const sectionActiveSensors = section.querySelectorAll('.sensor.active');\n    const input = section.querySelector('input');\n\n    input.checked = sectionActiveSensors.length === sensorsQtPerSection;\n  });\n\n  highlightAllCheckbox.checked = activeSensors.length === Constants.SENSORS_QT;\n}\n\n/**\n * Toggles the highlight in one sensor\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {HTMLInputElement} sensor The sensor to highlight\n * @param {Boolean} active If the sensor should be marked as active\n */\nfunction setHighlightSensor(sensor, active) {\n  if (active) {\n    sensor.classList.add('active');\n    sensor.setAttribute('data-active', true);\n  } else {\n    sensor.classList.remove('active');\n    sensor.removeAttribute('data-active');\n  }\n\n  checkSensorsHighlighted();\n}\n\n/**\n * Toggles the highlight in all sensors\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {HTMLChangeEvent} ev The event when the checkbox changed\n */\nfunction toggleHighlightSensors(ev) {\n  const shouldHighlight = ev.target.checked;\n\n  document.querySelectorAll('.sensor').forEach((sensor) => {\n    setHighlightSensor(sensor, shouldHighlight);\n  });\n}\n\n/**\n * Toggles the highlight in the sensors of the section\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {HTMLChangeEvent} ev The event when the checkbox changed\n */\nfunction toggleHighlightSection(ev) {\n  const sectionContainer = ev.target.parentElement.parentElement;\n  const shouldHighlight = ev.target.checked;\n\n  sectionContainer.querySelectorAll('.sensor').forEach((sensor) => {\n    setHighlightSensor(sensor, shouldHighlight);\n  });\n}\n\n/**\n * Creates the input field for the sensors\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {Number} sensorsQt The quantity of sensors\n */\nfunction createSensorInputs(sensorsQt) {\n  const sectionContainers = [\n    document.querySelector('#front-right-section > div'),\n    document.querySelector('#rear-right-section > div'),\n    document.querySelector('#rear-left-section > div'),\n    document.querySelector('#front-left-section > div'),\n  ];\n\n  for (let i = 1; i <= sensorsQt; i += 1) {\n    const sensorContainer = document.createElement('div');\n    const sensorTitle = document.createElement('span');\n    const sensorInput = document.createElement('input');\n    let sectionContainer = sectionContainers[Math.floor((i - 1) / 5)];\n\n    sensorTitle.textContent = i;\n\n    sensorInput.setAttribute('readonly', true);\n    sensorInput.setAttribute('type', 'text');\n    sensorInput.setAttribute('id', `sensor${i}`);\n\n    sensorContainer.classList.add('sensor');\n    sensorContainer.setAttribute('data-id', i);\n    sensorContainer.append(sensorTitle);\n    sensorContainer.append(sensorInput);\n\n    sensorContainer.addEventListener('click', (ev) => {\n      ev.stopPropagation();\n\n      const isActive = sensorContainer.dataset.active;\n\n      setHighlightSensor(sensorContainer, !isActive);\n    });\n\n    if (!sectionContainer) {\n      sectionContainer = sectionContainers[sectionContainers.length - 1];\n    }\n\n    sectionContainer.append(sensorContainer);\n  }\n}\n\n/**\n * Saves user's code in localStorage\n *\n * @author mauricio.araldi\n * @since 0.1.0\n *\n * @param {String} code The code to be saved\n * @return {Boolean} If the code is saved\n */\nfunction saveCode(code) {\n  if (!code) {\n    return false;\n  }\n\n  localStorage.setItem(Constants.LS_CODE_KEY, code);\n\n  return true;\n}\n\n/**\n * Loads user's code from localStorage\n *\n * @author mauricio.araldi\n * @since 0.1.0\n *\n * @return {String} User's code\n */\nfunction loadCode() {\n  const code = localStorage.getItem(Constants.LS_CODE_KEY);\n\n  if (!code) {\n    return null;\n  }\n\n  return code;\n}\n\nexport default {\n  checkSensorsHighlighted,\n  createSensorInputs,\n  loadCode,\n  saveCode,\n  setHighlightSensor,\n  toggleHighlightSection,\n  toggleHighlightSensors,\n  updateSensorsDisplay,\n};\n","/**\n * Converts degrees into radians, to use in canvas\n *\n * @author mauricio.araldi\n * @since 0.1.0\n *\n * @param {Number} degrees Degrees to be converted to radians\n * @return {Number} Radians obtained from the degrees\n */\nfunction degreesToRadians(degrees) {\n  return degrees * (Math.PI / 180);\n}\n\nexport default {\n  degreesToRadians,\n};\n","import SAT from 'sat';\n\nimport Utils from '../utils';\n\n/**\n * @class\n *\n * @param {SAT.Vector[]} area The area of the sensor\n * @param {Number} reading Current reading of the sensor\n */\nexport default class Sensor {\n  /**\n   * @constructor\n   *\n   * @param {Number} x The x origin point of the sensor\n   * @param {Number} y The y origin point of the sensor\n   * @param {Number} angle The angle to which the sensor will be drawn towards\n   * @param {Number} range The range of the sensor\n   * @param {Number} breakpointQt The quantity of breakpoints inside a sensor\n   */\n  constructor(x, y, angle, range, breakpointQt) {\n    this.area = this.getSensorArea(x, y, angle, range, breakpointQt);\n    this.reading = breakpointQt;\n  }\n\n  /**\n   * Gets the area of a sensor, acording to the car position\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @param {Number} originX The X point from where the sensor will be drawn\n   * @param {Number} originY The Y point from where the sensor will be drawn\n   * @param {Number} angle The angle to which the sensor will be drawn towards\n   * @param {Number} range The range of the sensor\n   * @param {Number} breakpointQt The quantity of breakpoints inside a sensor\n   * @return {SAT.Vector[]} The area of the sensor ({x, y}[])\n   */\n  getSensorArea(originX, originY, angle, range, breakpointQt) {\n    const interval = range / breakpointQt;\n    const area = [];\n\n    for (let i = 0; i < breakpointQt; i += 1) {\n      const offset = i * interval;\n      area.push(new SAT.Vector(\n        Math.floor(originX - (offset * Math.cos(Utils.degreesToRadians(angle)))),\n        Math.floor(originY - (offset * Math.sin(Utils.degreesToRadians(angle)))),\n      ));\n    }\n\n    return area;\n  }\n\n  /**\n   * Updates the sensor reading\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @param {GameObject[]} objects All the objects that can be perceived by the sensor\n   */\n  updateReading(objects) {\n    this.reading = this.area.length;\n\n    objects.some((object) => (\n      this.area.some((point, index) => {\n        if (SAT.pointInPolygon(point, object.polygon)) {\n          this.reading = index;\n          return true;\n        }\n\n        return false;\n      })\n    ));\n  }\n}\n","import SAT from 'sat';\n\n/**\n * @class\n *\n * @param {Number} x The x position\n * @param {Number} y The y position\n * @param {Number} width Width\n * @param {Number} height Height\n * @param {Number} angle Angle of rotation\n * @param {String} color HEX color\n * car should have\n */\nexport default class GameObject {\n  /**\n   * @constructor\n   *\n   * @param {Number} x The x position\n   * @param {Number} y The y position\n   * @param {Number} width Width\n   * @param {Number} height Height\n   * @param {Number} angle Angle of rotation\n   * @param {String} color HEX color\n   */\n  constructor(x, y, width, height, angle, color) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.angle = angle;\n    this.color = color;\n\n    this.polygon = new SAT.Polygon(\n      new SAT.Vector(x, y),\n      [\n        new SAT.Vector(0, 0),\n        new SAT.Vector(width, 0),\n        new SAT.Vector(width, height),\n        new SAT.Vector(0, height),\n      ],\n      width,\n      height,\n    );\n  }\n\n  /**\n   * Checks if this object is inside another object\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @param {GameObject} outerObject The object to be used as target area\n   * @return {Boolean} If the game object is inside target game object\n   */\n  testInsideAnotherObject(outerObject) {\n    const innerStartX = this.x;\n    const innerEndX = this.x + this.width;\n    const innerStartY = this.y;\n    const innerEndY = this.y + this.height;\n    const outerStartX = outerObject.x;\n    const outerEndX = outerObject.x + outerObject.width;\n    const outerStartY = outerObject.y;\n    const outerEndY = outerObject.y + outerObject.height;\n\n    return (\n      innerStartX >= outerStartX\n      && innerEndX <= outerEndX\n      && innerStartY >= outerStartY\n      && innerEndY <= outerEndY\n    );\n  }\n}\n","import SAT from 'sat';\nimport Sensor from './Sensor';\nimport GameObject from './GameObject';\nimport Constants from '../constants';\nimport Utils from '../utils';\n\n/**\n * @class\n * @extends GameObject\n *\n * @param {Object} brainState Current brain state of the car\n * @param {Number} sensorBreakpointQt Numbers of breakpoints each sensor of the\n * @param {Number} sensorRange The range of the sensors in pixels\n * @param {Object{id: Sensor}} sensors The sensors of the car\n * @param {Number} speed Current speed of the car\n */\nexport default class Car extends GameObject {\n  /**\n   * @constructor\n   *\n   * @param {String} color HEX color of the car\n   * @param {Number} x X position of the car\n   * @param {Number} y Y position of the car\n   * @param {Number} width Width of the car\n   * @param {Number} height Height of the car\n   * @param {Number} angle Angle of rotation of the car\n   * @param {Object} brainState Current brain state of the car\n   * @param {Number} speed Current speed of the car\n   * @param {Boolean} parkingBreak The current state of the parking break\n   * @param {Boolean} withSensors Of the car should have distance sensors\n   * @param {Number} sensorRange The range of the sensors in pixels\n   * @param {Number} sensorBreakpointQt Numbers of breakpoints each sensor of the\n   * car should have\n   */\n  constructor(color, x, y, width, height, angle, brainState, speed, parkingBreak,\n    withSensors, sensorRange, sensorBreakpointQt) {\n    super(x, y, width, height, angle, color);\n\n    this.brainState = brainState;\n    this.sensorBreakpointQt = sensorBreakpointQt;\n    this.sensorRange = sensorRange;\n    this.speed = speed;\n    this.parkingBreak = parkingBreak;\n\n    if (withSensors) {\n      this.sensors = this.buildSensors();\n    }\n  }\n\n  /**\n   * Builds the sensors of a car\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @return {Object{id: Sensor}} The sensors of the car by id\n   */\n  buildSensors() {\n    const points = this.polygon.points.map((carPoint) => (\n      { x: this.polygon.pos.x + carPoint.x, y: this.polygon.pos.y + carPoint.y }\n    ));\n    const angles = [\n      // Top Left\n      -45, 0, 45, 90, 135,\n\n      // Top Right\n      45, 90, 135, 180, 225,\n\n      // Bottom Right\n      135, 180, 225, 270, 315,\n\n      // Bottom Left\n      -135, -90, -45, 0, 45,\n    ];\n    const sensors = {};\n    const pointsPerAngle = angles.length / points.length;\n\n    for (let i = 0; i < angles.length; i += 1) {\n      const point = points[Math.floor((i || 1) / pointsPerAngle)];\n\n      sensors[i + 1] = new Sensor(\n        point.x,\n        point.y,\n        angles[i] + this.angle,\n        this.sensorRange,\n        this.sensorBreakpointQt,\n      );\n    }\n\n    return sensors;\n  }\n\n  /**\n   * Updates the sensors readings\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @param {GameObject[]} objects All the objects that can be perceived by the sensors\n   */\n  updateSensors(objects) {\n    Object.keys(this.sensors).forEach((key) => this.sensors[key].updateReading(objects));\n  }\n\n  /**\n   * Calculates how much the car's angle should change to match its brain state\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @return {Number} How much the angle changed\n   */\n  proccessCarBrainAngle() {\n    const angleState = this.brainState.angle;\n    let angleChange = 0;\n\n    if (this.angle !== angleState) {\n      const angleDiff = angleState - this.angle;\n\n      if (angleDiff > 0) {\n        angleChange = Math.min(angleDiff, Constants.MAX_ANGLE_CHANGE_PER_TICK);\n      } else if (angleDiff < 0) {\n        angleChange = Math.max(angleDiff, -Constants.MAX_ANGLE_CHANGE_PER_TICK);\n      }\n    }\n\n    this.angle += angleChange;\n\n    return angleChange;\n  }\n\n  /**\n   * Calculates how much the car's speed should change to match its brain state\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @return {Number} How much the speed changed\n   */\n  proccessCarBrainSpeed() {\n    let speedState = this.brainState.speed;\n    let speedChange = 0;\n\n    if (this.parkingBreak) {\n      speedState = 0;\n    }\n\n    if (this.speed !== speedState) {\n      const speedDiff = speedState - this.speed;\n\n      if (speedDiff > 0) {\n        speedChange = Math.min(speedDiff, Constants.MAX_SPEED_CHANGE_PER_TICK);\n      } else if (speedDiff < 0) {\n        speedChange = Math.max(speedDiff, -Constants.MAX_SPEED_CHANGE_PER_TICK);\n      }\n    }\n\n    this.speed += speedChange;\n\n    return speedChange;\n  }\n\n  /**\n   * Updates the car according to its brain state\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   */\n  update() {\n    this.proccessCarBrainSpeed();\n    const brainAngleChange = this.proccessCarBrainAngle();\n    const realSpeed = this.speed * (Math.abs(this.speed) / Constants.SPEED_RATIO);\n\n    if (!realSpeed) {\n      return;\n    }\n\n    const angleRad = Utils.degreesToRadians(this.angle);\n    const angleDiffRad = Utils.degreesToRadians(brainAngleChange);\n\n    this.x -= (realSpeed * Math.cos(angleRad));\n    this.y -= (realSpeed * Math.sin(angleRad));\n\n    this.polygon.pos.x = this.x;\n    this.polygon.pos.y = this.y;\n\n    const points = this.polygon.points.map((point) => {\n      const centerX = point.x - this.width / 2;\n      const centerY = point.y - this.height / 2;\n\n      const rotatedX = centerX * Math.cos(angleDiffRad) - centerY * Math.sin(angleDiffRad);\n      const rotatedY = centerX * Math.sin(angleDiffRad) + centerY * Math.cos(angleDiffRad);\n\n      return new SAT.Vector(\n        rotatedX + this.width / 2,\n        rotatedY + this.height / 2,\n      );\n    });\n\n    this.polygon.setPoints(points);\n  }\n}\n","/**\n * @class\n *\n * @param {Car} player The player's car\n * @param {GameObject[]} objects The objects which the player can collide\n * @param {Object} ground The ground layout\n * @param {GameObject} goalArea The goal area the player should reach\n * @param {GameObject[]} limits The limits of the level\n * @param {Function} goalReachedAction Action that executes as soon as goal is reached\n */\nexport default class Level {\n  /**\n   * @constructor\n   *\n   * @param {Car} player The player's car\n   * @param {GameObject[]} objects The objects which the player can collide\n   * @param {Object} ground The ground layout\n   * @param {GameObject} goalArea The goal area the player should reach\n   * @param {GameObject[]} limits The limits of the level\n   * @param {Function} goalReachedAction Action that executes as soon as goal is reached\n   */\n  constructor(player, objects, ground, goalArea, limits, goalReachedAction) {\n    this.player = player;\n    this.objects = objects;\n    this.ground = ground;\n    this.goalArea = goalArea;\n    this.limits = limits;\n    this.goalReachedAction = goalReachedAction;\n  }\n\n  /**\n   * Checks if the goal has been completed\n   *\n   * @author mauricio.araldi\n   * @since 0.2.0\n   *\n   * @return {Boolean} If the goal has been met\n   */\n  checkGoal() {\n    return this.player.testInsideAnotherObject(this.goalArea);\n  }\n}\n","import Noty from 'noty';\n\nimport Car from './objects/Car';\nimport Level from './objects/Level';\nimport GameObject from './objects/GameObject';\nimport Constants from './constants';\n\n/**\n * Gets a level configuration\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {Number} id Id of the level to be retrieved\n * @param {String[]} [colors] Array of colors to be used\n * @param {Number} [carWidth] Width of the cars\n * @param {Number} [carHeight] Height of the cars\n * @param {Number} [canvasWidth] Width of the canvas\n * @param {Number} [canvasHeight] Height of the canvas\n * @param {Number} [sensorRange] Range of the car's sensor\n * @param {Number} [sensorBreakpointQt] Quantity of breakpoints of car's sensor\n * @return {Level} The level configuration to be used\n */\nfunction getLevel(\n  id,\n  colors = Constants.COLORS,\n  carWidth = Constants.CAR_WIDTH,\n  carHeight = Constants.CAR_HEIGHT,\n  canvasWidth = Constants.CANVAS_WIDTH,\n  canvasHeight = Constants.CANVAS_HEIGHT,\n  sensorRange = Constants.SENSOR_RANGE,\n  sensorBreakpointQt = Constants.SENSOR_BREAKPOINTS_QT,\n) {\n  switch (id) {\n    case 1: return new Level(\n      new Car(\n        colors.player,\n        canvasWidth - (carWidth + 10),\n        carHeight + 60,\n        carWidth,\n        carHeight,\n        0,\n        {\n          angle: 0,\n          speed: 0,\n          memory: {},\n        },\n        0,\n        false,\n        true,\n        sensorRange,\n        sensorBreakpointQt,\n      ),\n      [\n        new Car(\n          colors.generic[0],\n          10,\n          10,\n          carWidth,\n          carHeight,\n        ),\n        new Car(\n          colors.generic[1],\n          (carWidth * 2) + (64 * 2),\n          10,\n          carWidth,\n          carHeight,\n        ),\n        new Car(\n          colors.generic[2],\n          (carWidth * 3) + (64 * 3),\n          10,\n          carWidth,\n          carHeight,\n        ),\n        new Car(\n          colors.generic[3],\n          (carWidth * 4) + (64 * 4),\n          10,\n          carWidth,\n          carHeight,\n        ),\n      ],\n      new GameObject(0, 0, canvasWidth, canvasHeight, 0, colors.asphalt),\n      new GameObject(\n        carWidth + 25,\n        5,\n        carWidth + 90,\n        carHeight + 10,\n        0,\n        colors.goalArea,\n      ),\n      [\n        new GameObject(-1, -2, canvasWidth + 2, 1),\n        new GameObject(-1, canvasHeight + 1, canvasWidth + 2, 1),\n        new GameObject(-2, 0, 1, canvasHeight),\n        new GameObject(canvasWidth + 1, 0, 1, canvasHeight),\n      ],\n      () => {\n        new Noty({\n          text: 'You reached the goal!',\n          type: 'success',\n        }).show();\n\n        gtag('event', 'won', {\n          'event_category': 'play',\n          'event_label': 'level_1',\n        });\n      },\n    );\n\n    default:\n      return null;\n  }\n}\n\nexport default {\n  getLevel,\n};\n","import Constants from './constants';\n\n/**\n * Draws the sensors to show their ranges\n *\n * @author mauricio.araldi\n * @since 0.1.0\n *\n * @param {CanvasRenderingContext2D} ctx Canvas context do render content\n * @param {Number[]} sensorIds IDs of the sensors to be drawn\n * @param {Car} car The car with the sensors to be drawn\n */\nfunction drawSensors(sensorIds, car) {\n  const canvas = document.querySelector('canvas');\n  const ctx = canvas.getContext('2d');\n  ctx.strokeStyle = Constants.COLORS.sensor;\n  ctx.lineWidth = 2;\n\n  sensorIds.forEach((id) => {\n    const { area } = car.sensors[id];\n\n    ctx.beginPath();\n    ctx.moveTo(area[0].x, area[0].y);\n    ctx.lineTo(area[area.length - 1].x, area[area.length - 1].y);\n    ctx.closePath();\n    ctx.stroke();\n  });\n\n  ctx.restore();\n}\n\nexport default {\n  drawSensors,\n};\n","import CodeMirror from 'codemirror/lib/codemirror';\nimport 'codemirror/mode/javascript/javascript';\nimport 'noty/lib/noty.css';\nimport 'noty/lib/themes/metroui.css';\nimport Noty from 'noty';\n\nimport Scene from './objects/Scene';\n\nimport Constants from './constants';\nimport Interface from './interface';\nimport LevelManager from './levelManager';\nimport Stage from './stage';\n\nimport '../styles/index.css';\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/paraiso-dark.css';\n\nconst CURRENT_LEVEL = 1;\n\nlet codeMirror;\nlet animationTicker;\nlet brainTicker;\n\nNoty.overrideDefaults({\n  layout: 'center',\n  theme: 'metroui',\n  timeout: 3000,\n});\n\n/**\n * Updates the animation\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {Scene} scene Current game scene\n * @param {Level} level The current game level\n */\nfunction animationTick(scene, level) {\n  const {\n    goalArea, ground, player, objects, limits, goalReachedAction,\n  } = level;\n  const highlightSensors = document.querySelectorAll('.sensor.active');\n  let collisions = null;\n\n  scene.clear();\n  scene.draw([ground, ...objects, player]);\n  scene.draw(goalArea, false);\n\n  if (player.parkingBreak && level.checkGoal()) {\n    runSimulation(false, false);\n\n    goalReachedAction();\n\n    return;\n  }\n\n  player.update();\n\n  player.sensors = player.buildSensors();\n\n  if (highlightSensors.length) {\n    const ids = [];\n\n    highlightSensors.forEach((sensor) => ids.push(parseInt(sensor.dataset.id, 10)));\n\n    Stage.drawSensors(ids, player);\n  }\n\n  collisions = scene.checkCollisions([...objects, player, ...limits]);\n\n  if (collisions.length) {\n    runSimulation(false);\n    new Noty({\n      text: 'Your car crashed!',\n      type: 'error',\n    }).show();\n  }\n}\n\n/**\n * Updats the brain information\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {Car} player The car of the player\n * @param {GameOBject[]} sceneObjects The current objects in the scene\n * @param {GameObject[]} limits The limits of the scenario\n * @return {Object} The new state of the player's car brain\n */\nfunction brainTick(player, sceneObjects, limits) {\n  const brainCode = codeMirror.getValue();\n  const carInstructions = { sensors: player.sensors, memory: player.brainState.memory };\n  let newBrainState = null;\n\n  player.updateSensors([...sceneObjects, ...limits]);\n  Interface.updateSensorsDisplay(player.sensors);\n\n  eval.call({}, `(${brainCode})`)(carInstructions); // eslint-disable-line no-eval\n\n  newBrainState = { ...player.brainState, ...carInstructions };\n\n  newBrainState.angle = Math.min(newBrainState.angle, Constants.MAX_ANGLE);\n  newBrainState.sensors = player.sensors;\n\n  player.brainState = newBrainState;\n  player.parkingBreak = newBrainState.parkingBreak;\n}\n\n/**\n * Starts or stops the simulation\n *\n * @author mauricio.araldi\n * @since 0.2.0\n *\n * @param {Boolean} play If the simulation should be played\n * @param {Boolean} reset If the game should be resetted\n */\nfunction runSimulation(play, reset = true) {\n  const currentLevel = LevelManager.getLevel(CURRENT_LEVEL);\n  const canvas = document.querySelector('canvas');\n  const scene = new Scene(canvas);\n  const { objects, player, limits } = currentLevel;\n\n  if (play && !animationTicker) {\n    animationTicker = setInterval(\n      () => animationTick(scene, currentLevel),\n      1000 / Constants.FRAMES_PER_SECOND,\n    );\n\n    brainTicker = setInterval(\n      () => brainTick(player, objects, limits),\n      1000 / Constants.BRAIN_TICKS_PER_SECOND,\n    );\n  } else if (!play) {\n    clearInterval(animationTicker);\n    clearInterval(brainTicker);\n\n    animationTicker = null;\n    brainTicker = null;\n\n    if (reset) {\n      animationTick(scene, currentLevel);\n    }\n  }\n}\n\n/* Initial setup */\nwindow.onload = () => {\n  const canvas = document.querySelector('canvas');\n\n  canvas.width = Constants.CANVAS_WIDTH;\n  canvas.height = Constants.CANVAS_HEIGHT;\n\n  Interface.createSensorInputs(Constants.SENSORS_QT);\n\n  codeMirror = CodeMirror.fromTextArea(\n    document.querySelector('#code-editor'),\n    {\n      lineNumbers: true,\n      mode: 'javascript',\n      theme: 'paraiso-dark',\n    },\n  );\n\n  const codeMirrorElement = document.querySelector('.CodeMirror');\n  const codeMirrorTop = codeMirrorElement.getClientRects()[0].top;\n  const codeMirrorHeight = window.innerHeight - codeMirrorTop;\n  const code = Interface.loadCode();\n\n  codeMirrorElement.style.height = `${codeMirrorHeight}px`;\n\n  if (code) {\n    codeMirror.setValue(code);\n  } else {\n    codeMirror.getDoc().setValue(`function carBrain(car) {\n  car.speed = 20;\n\n  if (car.sensors[3].reading === 10 && car.sensors[4].reading === 10) {\n    car.speed = 0;\n  } else if (car.sensors[3].reading >= 6) {\n    car.angle = 5;\n  } else if (car.sensors[3].reading <= 4) {\n    car.angle = -5;\n  }\n}`);\n  }\n\n  runSimulation(false);\n\n  /* Actions */\n  document.querySelector('#play').addEventListener('click', () => runSimulation(true));\n  document.querySelector('#stop').addEventListener('click', () => runSimulation(false));\n  document.querySelector('#save').addEventListener('click', () => Interface.saveCode(codeMirror.getValue()));\n  document.querySelector('#highlight-all-sensors').addEventListener('change', Interface.toggleHighlightSensors);\n\n  document.querySelectorAll('.sensor-section').forEach((element) => {\n    const input = element.querySelector('input');\n\n    element.addEventListener('change', Interface.toggleHighlightSection);\n    input.checked = false;\n  });\n\n  document.querySelector('#highlight-all-sensors').checked = false;\n};\n"],"sourceRoot":""}